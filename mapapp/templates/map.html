<!DOCTYPE html>
<html lang="ro">
<head>
    {% load static %}
    <meta charset="UTF-8"/>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <title>TERMOELECTRICA S.A.</title>

    <!-- Leaflet & MarkerCluster CSS -->
    <link href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" rel="stylesheet"/>
    <link href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" rel="stylesheet"/>
    <link href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" rel="stylesheet"/>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>

    <script src="{% static 'sectors.js' %}"></script>

    <style>
        :root{ --header-h: 60px; }

        body { font-family: Arial, sans-serif; text-align: center; background-color: #f4f4f4; margin: 0; padding: 0; }

        .header {
            display: flex; flex-wrap: wrap; align-items: flex-start; justify-content: space-between;
            row-gap: 0; width: 100vw; max-width: none; margin: 0;
            position: fixed; top: 0; left: 0; z-index: 10;
            background: #7291bf; color: rgba(255,255,255,.90); padding: 0 10px;
        }

        h1 { color: inherit; margin: 0; text-align: left; padding-left: 30px; }

        #search-container { order: 3; margin-left: auto; display: flex; align-items: center; gap: 5px; z-index: 11; }

        #sector-buttons {
            order: 2; flex-grow: 1; display: flex; justify-content: center; gap: 15px;
            flex-wrap: wrap; margin: 0; width: auto; position: static; background: none; padding: 0;
        }

        #map {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            width: 100vw; height: 100vh; z-index: 1; border: none; border-radius: 0;
            box-shadow: none; margin: 0; max-width: none;
        }

        #limits-box, #limits-tooltip, #status-filter, #status-list { position: fixed; z-index: 12; }

        #limits-box {
            top: 55px; left: 71px; width: 30px; height: 30px; line-height: 30px; font-size: 18px;
            background-color: #32d74b; color: #fff; font-weight: bold; text-align: center;
            border-radius: 8px; box-shadow: 0 0 7px rgba(0,0,0,0.28);
            border: 2.5px solid #149c21; cursor: pointer;
            transition: background 0.15s, box-shadow 0.2s;
        }
        #limits-box:hover { background-color: #23b037; box-shadow: 0 0 15px #32d74b99; }
        #limits-tooltip { top: 60px; left: 105px; }

        #status-filter {
            top: 150px; left: 20px; display: flex; flex-direction: column; gap: 22px;
            z-index: 1002; font-size: 20px; font-weight: bold; color: #333; line-height: 1.4;
        }
        #status-filter > div > div:not(.filter-icon) { font-size: 19px; font-weight: bold; color: #2c2c2c; margin-left: 8px; }
        #status-list { top: 150px; left: 60px; }

        /* ✅ сдвиг всех Leaflet-контролов ниже шапки */
        .leaflet-top{ top: calc(var(--header-h) + 10px) !important; }

        #search-box { padding: 8px; width: 200px; border: 1px solid #ccc; border-radius: 4px; }
        #search-button { padding: 8px 15px; background-color: #2c3e50; color: white; border: none; border-radius: 4px; cursor: pointer; }
        #search-button:hover { background-color: #1a252f; }

        /* ✅ убрать стрелку (dropdown) у input с datalist в Chrome/Edge */
        #search-box::-webkit-calendar-picker-indicator {
            display: none !important;
            opacity: 0 !important;
        }

        #search-button { display: none !important; }



        #sector-buttons button {
            padding: 5px 30px; font-size: 16px; font-weight: bold;
            background: linear-gradient(180deg, #222 0%, #000 100%);
            border: 3px solid #bbb; border-radius: 50px; color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.8), inset 0 2px rgba(255, 255, 255, 0.3), inset 0 -2px 3px rgba(0, 0, 0, 0.6);
            transition: all 0.3s ease;
        }
        #sector-buttons button.active {
            background: linear-gradient(180deg, #444 0%, #111 100%);
            border-color: green;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.9), inset 0 3px rgba(255, 255, 255, 0.5), inset 0 -3px 4px rgba(0,  0, 0, 0.7);
            transform: scale(1.02);
        }
        #sector-buttons button:hover { background: linear-gradient(180deg, #333 0%, #111 100%); transform: scale(1.05); border-color: white; }




        .hidden { display: none; }
        .filter-icon { width: 34px; height: 34px; border-radius: 50%; cursor: pointer; border: 2px solid #333; }

        #status-list {
            background: #fff; padding: 10px; border: 1px solid #999; border-radius: 6px;
            box-shadow: 0 0 6px rgba(0, 0, 0, 0.2);
            z-index: 1003; max-height: 300px; overflow-y: auto;
            font-size: 15px; text-align: left;
        }
        #status-list div { cursor: pointer; padding: 4px 0; border-bottom: 1px solid #eee; }
        #status-list div:hover { background-color: #f0f0f0; }

        .station-ico { width: 48px; height: 48px; position: relative; border: 2px solid black; border-radius: 6px; box-shadow: 0 0 5px rgba(0,0,0,0.5); overflow: hidden; background: rgba(255,255,255,0.75); display: flex; align-items: center; justify-content: center; }
        .station-ico img.base { width: 100%; height: 100%; object-fit: contain; display: block; }

        .station-ico.sp { background: transparent !important; border: none !important; box-shadow: none !important; overflow: visible !important; width: 0 !important; height: 0 !important; }
        .station-ico.sp .rotor {
    position: absolute; left: 0; top: 0;
    width: 20px; height: 20px;
    border-radius: 50%;
    border: 2px solid rgba(0,0,0,0.45);
    opacity: 0.95;
}


        .station-ico.sp.run .rotor {
    background: conic-gradient(
        rgba(255, 0, 0, 1) 0 15%,
        rgba(128, 0, 0, 0.22) 15% 25%,
        rgba(255, 0, 0, 1) 25% 40%,
        rgba(128, 0, 0, 0.22) 40% 50%,
        rgba(255, 0, 0, 1) 50% 65%,
        rgba(128, 0, 0, 0.22) 65% 75%,
        rgba(255, 0, 0, 1) 75% 90%,
        rgba(128, 0, 0, 0.22) 90% 100%
    );
    box-shadow: 0 0 12px rgba(255, 0, 0, 0.65);
    animation: spin 2s linear infinite;
}

        .station-ico.sp.stop .rotor {
    background: conic-gradient(
        rgba(0, 128, 0, 1) 0 15%,
        rgba(0, 64, 0, 0.22) 15% 25%,
        rgba(0, 128, 0, 1) 25% 40%,
        rgba(0, 64, 0, 0.22) 40% 50%,
        rgba(0, 128, 0, 1) 50% 65%,
        rgba(0, 64, 0, 0.22) 65% 75%,
        rgba(0, 128, 0, 1) 75% 90%,
        rgba(0, 64, 0, 0.22) 90% 100%
    );
    box-shadow: 0 0 10px rgba(0, 128, 0, 0.45);
    animation: none;
}

        @keyframes spin { from {transform: translate(-50%, -50%) rotate(0deg);} to {transform: translate(-50%, -50%) rotate(360deg);} }

        .station-ico.ct, .station-ico.disp { background: transparent !important; border: none !important; box-shadow: none !important; overflow: visible !important; border-radius: 0 !important; display: block !important; }
        .station-ico.cet{ background: transparent !important; border: none !important; box-shadow: none !important; overflow: visible !important; border-radius: 0 !important; display: block !important; }

        .station-ico .tri{
            width: 0; height: 0;
            border-left: 14px solid transparent;
            border-right: 14px solid transparent;
            border-bottom: 26px solid rgba(0,128,0,1);
            filter: drop-shadow(0 0 3px rgba(0,0,0,0.35));
        }
        .station-ico.ct .tri{ border-left-width: 18px; border-right-width: 18px; border-bottom-width: 30px; }
        .station-ico.cet .tri{ border-left-width: 20px; border-right-width: 20px; border-bottom-width: 35px; }
        .station-ico.disp .tri{ border-left-width: 10px; border-right-width: 10px; border-bottom-width: 18px; }

        .station-ico.ct.run .tri, .station-ico.disp.run .tri, .station-ico.cet.run .tri{ border-bottom-color: red; }
        .station-ico.ct.stop .tri, .station-ico.disp.stop .tri, .station-ico.cet.stop .tri{ border-bottom-color: #008000; }

        .station-ico.disp{ width: 0 !important; height: 0 !important; }
        .station-ico.ct, .station-ico.cet{ width: 0 !important; height: 0 !important; }


        .boiler-div-icon{ background: transparent !important; border: none !important; }

        .leaflet-control-zoom { display: none; }

        .fullscreen-custom {
            background: #fff; width: 30px; height: 30px; line-height: 30px; text-align: center;
            font-size: 16px; font-weight: bold; cursor: pointer; margin-top: 0;
        }
        .fullscreen-custom span { display: block; }
        .fullscreen-custom:hover { background: #f0f0f0; }

        .leaflet-control-fullscreen { margin-top: 0 !important; }

        .btn { display: inline-flex; align-items: center; justify-content: center; gap: .25rem; text-decoration: none; cursor: pointer; user-select: none; white-space: nowrap; }
        .btn-sm { height: 26px; padding: 0 10px; border-radius: 6px; font-size: 13px; line-height: 1; }
        .btn-outline-light { color: #fff; background: transparent; border: 1px solid rgba(255,255,255,.85); }
        .btn-outline-light:hover { background: #fff; color: #111; text-decoration: none; }

        .footer {
            position: fixed;
            left: 10px;
            bottom: 8px;
            z-index: 1005;
            font-size: 12px;
            color: #eee;
            background: rgba(0, 0, 0, 0.45);
            padding: 4px 8px;
            border-radius: 6px;
            pointer-events: none;
            user-select: none;
        }

        /* ===== LOADING overlay (anti-freeze UI) ===== */
        #loading-overlay{
            position: fixed;
            inset: 0;
            z-index: 3000;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,.35);
        }
        #loading-overlay.hidden{ display:none; }
        .loading-card{
            background: rgba(0,0,0,.75);
            color:#fff;
            padding: 14px 16px;
            border-radius: 10px;
            min-width: 180px;
            text-align:center;
            box-shadow: 0 10px 30px rgba(0,0,0,.35);
            font-weight: 700;
            letter-spacing: .3px;
        }
        .spinner{
            width: 36px;
            height: 36px;
            margin: 0 auto 10px;
            border-radius: 50%;
            border: 4px solid rgba(255,255,255,.35);
            border-top-color: #fff;
            animation: spin2 1s linear infinite;
        }
        @keyframes spin2 { to { transform: rotate(360deg); } }
    </style>
</head>

<body>
<div class="header">
    <a href="http://10.1.1.248:1010/" class="btn btn-outline-light btn-sm" rel="noopener">SCADA&nbsp;Portal</a>
    <h1>Harta Sinoptică</h1>

    <div id="search-container">
        <input id="search-box" list="search-history" placeholder="Întroduceți Nr obiectului..." type="text"/>
        <datalist id="search-history"></datalist>
        <button id="search-button">CAUTĂ</button>
    </div>

    <div id="sector-buttons">
        <button data-sector="1">Centru</button>
        <button data-sector="2">Rășcani</button>
        <button data-sector="3">Botanica</button>
        <button data-sector="4">Buiucani</button>
        <button data-sector="6">Ciocana</button>
        <button data-sector="0">Arată Toate</button>


    </div>
</div>

<div id="limits-box">L</div>
<div class="hidden" id="limits-tooltip">Loading...</div>

<div id="status-filter" style="display:flex; flex-direction:column; gap:20px; align-items:center;">
    <div style="display:flex; flex-direction:column; align-items:center">
        <div class="filter-icon" data-color="red" style="background-color:red"></div>
        <div style="font-size:12px; color:#333; text-align:center">Temperatura ridicată</div>
    </div>
    <div style="display:flex; flex-direction:column; align-items:center">
        <div class="filter-icon" data-color="green" style="background-color:green"></div>
        <div style="font-size:12px; color:#333; text-align:center">Temperatura în normă</div>
    </div>
    <div style="display:flex; flex-direction:column; align-items:center">
        <div class="filter-icon" data-color="blue" style="background-color:blue"></div>
        <div style="font-size:12px; color:#333; text-align:center">Temperatura joasă</div>
    </div>
    <div style="display:flex; flex-direction:column; align-items:center">
        <div class="filter-icon" data-color="black" style="background-color:black"></div>
        <div style="font-size:12px; color:#333; text-align:center">Date expirate</div>
    </div>
</div>

<div class="hidden" id="status-list"></div>

<!-- LOADING overlay -->
<div id="loading-overlay" class="hidden" aria-live="polite" aria-busy="true">
    <div class="loading-card">
        <div class="spinner"></div>
        <div id="loading-message">LOADING…</div>
    </div>
</div>

<div id="map"></div>

<script>
    const $ = (sel, root = document) => root.querySelector(sel);
    const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));

    function normalizePumpKey(s) {
    return (s || "")
        .trim()
        .toLowerCase()
        .replace(/^pt_/, "")
        .replace(",", ".")      // ✅ запятая -> точка
        .replace(/\s+/g, "");   // ✅ убрать пробелы внутри
}


    function updateHeaderOffset() {
        const header = document.querySelector('.header');
        if (!header) return;
        document.documentElement.style.setProperty('--header-h', header.offsetHeight + 'px');
    }

    function updatePopupTemps(popup, t1Live, t2Live) {
        if (!popup) return;
        let content = popup.getContent();
        content = content
            .replace(/<b>T1:<\/b>[^<]*°C/, `<b>T1:</b> ${t1Live} °C`)
            .replace(/<b>T2:<\/b>[^<]*°C/, `<b>T2:</b> ${t2Live} °C`);
        popup.setContent(content).update();
    }

    // ✅ LOADING прямо в POPUP (T1/T2)
    function setPopupLoading(popup, label = "LOADING...") {
        if (!popup) return;
        let content = popup.getContent();
        content = content
            .replace(/<b>T1:<\/b>[^<]*°C/, `<b>T1:</b> ${label} °C`)
            .replace(/<b>T2:<\/b>[^<]*°C/, `<b>T2:</b> ${label} °C`);
        popup.setContent(content).update();
    }

    // fetch с таймаутом (чтобы запрос не висел бесконечно)
    async function fetchWithTimeout(url, options = {}, timeoutMs = 15000) {
        const ctrl = new AbortController();
        const t = setTimeout(() => ctrl.abort(), timeoutMs);
        try {
            return await fetch(url, { ...options, signal: ctrl.signal });
        } finally {
            clearTimeout(t);
        }
    }

    const FETCH_CACHE_TTL_MS = 5000;
    const fetchCache = new Map();

    // ✅ кеш + таймаут + проверка ok
    async function fetchJsonCached(url, ttlMs = FETCH_CACHE_TTL_MS, timeoutMs = 15000) {
        const now = Date.now();
        const cached = fetchCache.get(url);
        if (cached && (now - cached.t) < ttlMs) return cached.data;

        const resp = await fetchWithTimeout(url, {}, timeoutMs);
        if (!resp.ok) throw new Error("HTTP " + resp.status);

        const data = await resp.json();
        fetchCache.set(url, { t: now, data });
        return data;
    }

    // ✅ авто-открытие объекта по URL (?ptc=... / ?obiect=... / ?q=...)
    let pendingAutoQuery = null;

    function getQueryFromUrl() {
        const params = new URLSearchParams(window.location.search);
        return params.get("ptc") || params.get("obiect") || params.get("q");
    }

    // ✅ обновление адресной строки без перезагрузки (чтобы ссылку можно было копировать/менять)
    function setUrlPtc(value) {
        const url = new URL(window.location.href);
        if (value) url.searchParams.set("ptc", value);
        else url.searchParams.delete("ptc");
        window.history.replaceState({}, "", url.toString());
    }

    const map = L.map("map", { maxZoom: 20 }).setView([47.01, 28.86], 12);
    const DETAILS_ZOOM = 17;

    window.addEventListener('load', updateHeaderOffset);
    window.addEventListener('resize', updateHeaderOffset);
    setTimeout(updateHeaderOffset, 200);
    setTimeout(updateHeaderOffset, 800);

    const osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: "© OpenStreetMap contributors",
        maxZoom: 20,
        maxNativeZoom: 19
    });

    const cartoLight = L.tileLayer("https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png", {
        attribution: "© OpenStreetMap © CARTO",
        maxZoom: 20,
        maxNativeZoom: 20
    });

    const esriSat = L.tileLayer(
        "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
        { attribution: "Tiles © Esri", maxZoom: 20, maxNativeZoom: 19 }
    );

    osm.addTo(map);
    L.control.layers({
        "OpenStreetMap": osm,
        "Carto Light": cartoLight,
        "Satellite (Esri)": esriSat
    }, null, { position: "topleft" }).addTo(map);

    const markers = L.markerClusterGroup({
        maxClusterRadius: 70,
        disableClusteringAtZoom: 17,
    });

    const pumpMarkers = {};
    const iconCache = {};

    const PUMP_FONT_PX = 12;
    const PUMP_PAD_Y = 2;
    const PUMP_PAD_X = 6;
    const PUMP_RADIUS = 5;
    const PUMP_MIN_W = 34;

    let limits = {};
    let lastBulkUpdate = 0;

    let pumpsLoaded = false;
    let pumpsLoading = false;
    let pipelinesLoaded = false;
    let pipelinesLoading = false;
    let zadviscaLoaded = false;

    let heatPipelineLayer = null;
    let zadviscaLayer = null;

    // ✅ zadvisca: traducere RO (fără culori) + aspect ca înainte
const NAME_LAYER_META = {
    "камера_подземная_квартальная": { ro: "Cameră subterană de cartier" },
    "камера_подвал":               { ro: "Cameră în subsol" },
    "камера_подземная_магистральная": { ro: "Cameră subterană magistrală" },
    "камера_магистральная_головная":  { ro: "Cameră magistrală principală" },

    "стойка_квартальная":            { ro: "Stâlp de cartier" },
    "стойка_магистральная":          { ro: "Stâlp magistral" },
    "стойка_магистральная_головная": { ro: "Stâlp magistral principal" },

    "павильон_задвижек": { ro: "Pavilion de vane" }
};



let zadviscaGeojsonData = null;

function getNameLayerRO(nl) {
    return (nl && NAME_LAYER_META[nl] && NAME_LAYER_META[nl].ro) ? NAME_LAYER_META[nl].ro : nl;
}

function refreshZadviscaLayer() {
    if (!zadviscaGeojsonData) return;

    if (zadviscaLayer) {
        try { map.removeLayer(zadviscaLayer); } catch(e) {}
        zadviscaLayer = null;
    }

    zadviscaLayer = L.geoJSON(zadviscaGeojsonData, {
        // ✅ без фильтрации по name_layer (шеф сказал не нужно)
        pointToLayer: (feature, latlng) => {
            // ✅ спокойный стиль как раньше + в 2 раза меньше чем было (12 -> 6)
            return L.circleMarker(latlng, {
                radius: 7,
                color: "black",
                weight: 1,
                fillColor: "yellow",
                fillOpacity: 0.7,
            });
        },
        onEachFeature: function (feature, layer) {
            const props = feature.properties || {};

            // ✅ переводим name_layer на румынский в popup/tooltip
            const title =
                props.name_layer ? getNameLayerRO(props.name_layer) :
                (props.consumer_purpose || props.name_node || props.name_chamber || "");

            const lines = [];
            if (title) lines.push(`<div style="font-weight:bold">${title}</div>`);
            if (props.name_chamber && props.name_chamber !== title) lines.push(`<div>${props.name_chamber}</div>`);
            if (props.additional_information) lines.push(`<div>${props.additional_information}</div>`);

            const popupHtml = lines.join('');
            layer.bindPopup(popupHtml);

            if (title) layer.bindTooltip(title, {direction: 'top', offset: [0, -6], opacity: 0.9});
        },
    });

    if (map.getZoom() >= DETAILS_ZOOM) {
        zadviscaLayer.addTo(map);
    }
}



    // ===== LOADING (overlay) =====
    const loadingOverlay = document.getElementById('loading-overlay');
    const loadingMessage = document.getElementById('loading-message');
    let loadingCount = 0;
    let loadingSafetyTimer = null;

    function showLoading(msg = 'LOADING…') {
        loadingCount++;
        if (loadingMessage) loadingMessage.textContent = msg;
        if (loadingOverlay) loadingOverlay.classList.remove('hidden');

        if (loadingSafetyTimer) clearTimeout(loadingSafetyTimer);
        loadingSafetyTimer = setTimeout(() => {
            loadingCount = 0;
            if (loadingOverlay) loadingOverlay.classList.add('hidden');
        }, 20000);
    }

    function hideLoading() {
        loadingCount = Math.max(0, loadingCount - 1);
        if (loadingCount === 0) {
            if (loadingSafetyTimer) clearTimeout(loadingSafetyTimer);
            loadingSafetyTimer = null;
            if (loadingOverlay) loadingOverlay.classList.add('hidden');
        }
    }

    // ===== ✅ УМНЫЕ ПОДСКАЗКИ ПО ПРЕФИКСУ (datalist) =====
    function getAllPtcKeysSorted() {
    return Object.keys(pumpMarkers)
        .filter(k => /^\d+(\.\d+)?$/.test(k))
        .sort((a, b) => parseFloat(a) - parseFloat(b));
}


    function updateSearchDatalistByPrefix(prefix) {
        const dl = document.getElementById("search-history");
        if (!dl) return;

        dl.innerHTML = "";

        const p = (prefix || "").trim();
        if (!p) return;

        if (!pumpsLoaded) return;

        const keys = getAllPtcKeysSorted();
        const matches = keys.filter(k => k.startsWith(p));

        const LIMIT = 80;
        matches.slice(0, LIMIT).forEach((k) => {
            const opt = document.createElement("option");
            opt.value = k;
            dl.appendChild(opt);
        });
    }

    function isExactExistingPtc(value) {
        const k = normalizePumpKey(value);
        return !!pumpMarkers[k];
    }

    function getColoredIcon(name, color) {
        const key = `${name}_${color}`;
        if (!iconCache[key]) {
            const h = PUMP_FONT_PX + (PUMP_PAD_Y * 2) + 6;
            iconCache[key] = L.divIcon({
                className: "",
                html: `
                    <div style="
                        display:inline-block;
                        min-width:${PUMP_MIN_W}px;
                        padding:${PUMP_PAD_Y}px ${PUMP_PAD_X}px;
                        font-size:${PUMP_FONT_PX}px;
                        font-weight:700;
                        line-height:1.1;
                        color:white;
                        border-radius:${PUMP_RADIUS}px;
                        background-color:${color};
                        box-shadow:0 1px 3px rgba(0,0,0,.35);
                        text-align:center;
                        white-space:nowrap;
                    ">
                        ${String(name).replace(/^PT_/i, "")}
                    </div>
                `,
                iconSize: null,
                popupAnchor: [0, -h],
            });
        }
        return iconCache[key];
    }

    function getCombinedMarkerColor(t1, t2, timestamp) {
        const now = Date.now();
        const ageMin = (now - new Date(timestamp).getTime()) / 60000;
        if (ageMin > 15 || (isNaN(t1) && isNaN(t2))) return "black";

        const over =
            (t1 != null && !isNaN(t1) && t1 > limits.T1max) ||
            (t2 != null && !isNaN(t2) && t2 > limits.T2);

        const under =
            t1 != null && !isNaN(t1) && t1 < limits.T1min &&
            t2 != null && !isNaN(t2) && t2 < 35;

        if (over) return "red";
        if (under) return "blue";
        return "green";
    }

    function updateMarkersColors() {
        if (Date.now() - lastBulkUpdate < 10000) return;
        lastBulkUpdate = Date.now();

        fetchJsonCached("api/live_temp_bulk/", 3000, 15000)
            .then((data) => {
                Object.entries(pumpMarkers).forEach(([key, marker]) => {
                    const temps = data[key];
                    if (!temps) return;

                    const t1 = parseFloat(temps.T1);
                    const t2 = parseFloat(temps.T2);
                    const timestamp = temps.timestamp || new Date().toISOString();

                    const color = getCombinedMarkerColor(t1, t2, timestamp);

                    // ✅ не перерисовывать иконку, если цвет не поменялся
                    if (marker._ptcColor === color) return;
                    marker._ptcColor = color;

                    marker.setIcon(getColoredIcon(marker._displayName || key, color));
                });
            })
            .catch((err) => console.error("Ошибка обновления маркеров:", err));
    }

    function fetchExteriorTemp() {
        fetchJsonCached("api/temperature_limits/", 5000, 15000)
            .then((data) => {
                limits = data;
                updateMarkersColors();

                const tt = document.getElementById("limits-tooltip");
                tt.style.whiteSpace = "pre";
                tt.textContent =
                    `Text = ${limits.Text}°C    T1min = ${limits.T1min}°C    T1max = ${limits.T1max}°C    T2 = ${limits.T2}°C    Tacm = ${limits.Tacm}°C`;
            })
            .catch((err) => console.error("Ошибка загрузки лимитов:", err));
    }

    let exteriorTimer = null;

    function finalizePumpsLoad() {
        if (!map.hasLayer(markers)) map.addLayer(markers);

        const v = ($("#search-box").value || "").trim();
        if (v) updateSearchDatalistByPrefix(normalizePumpKey(v));

        if (pendingAutoQuery) {
            setTimeout(() => {
                searchObject();
                pendingAutoQuery = null;
            }, 50);
        }

        fetchExteriorTemp();
        if (!exteriorTimer) exteriorTimer = setInterval(fetchExteriorTemp, 60000);
    }

    async function fetchAndRenderPumps() {
        if (pumpsLoaded || pumpsLoading) return;

        pumpsLoading = true;
        showLoading("LOADING PUMPS…");

        try {
            const res = await fetchWithTimeout("api/pumps/", {}, 20000);
            if (!res.ok) throw new Error("HTTP " + res.status);

            const data = await res.json();
            if (!Array.isArray(data)) throw new Error("Bad JSON (expected array)");

            const CHUNK = 200;
            let i = 0;

            function makeMarker(pump) {
                const type = pump.type_device === 1 ? "PTC" : "PTI";
                const t1Display = (pump.T1 == null || isNaN(pump.T1)) ? "N" : pump.T1;
                const t2Display = (pump.T2 == null || isNaN(pump.T2)) ? "N" : pump.T2;

                const key = normalizePumpKey(pump.param_name);

                const marker = L.marker([pump.lat, pump.longitude], {
                    icon: getColoredIcon(pump.param_name, "green"),
                    number_map: pump.number_map,
                }).bindPopup(
                    `<b>${type}</b><br><b>${String(pump.param_name).replace(/^PT_/i, "")}</b><br>${pump.address}<br>
                     <b>T1:</b> ${t1Display} °C<br><b>T2:</b> ${t2Display} °C<br>
                     <a href='http://10.1.1.174/view/view_page.php?title=${encodeURIComponent(String(pump.param_name).replace(/\./g, "").replace("PT_", ""))}' target='_blank'>Schema</a>`
                );

                marker._displayName = pump.param_name;
                marker._ptcKey = key;
                marker._ptcColor = "green";

                // ✅ LOADING в попапе + живые температуры по popupopen
                marker.on("popupopen", () => {
                    setPopupLoading(marker.getPopup(), "LOADING...");

                    fetchJsonCached(`api/live_temp/${encodeURIComponent(pump.param_name)}/`, 3000, 15000)
                        .then((d) => {
                            const t1Live = (d.T1 == null || isNaN(d.T1)) ? "N" : d.T1;
                            const t2Live = (d.T2 == null || isNaN(d.T2)) ? "N" : d.T2;
                            updatePopupTemps(marker.getPopup(), t1Live, t2Live);
                        })
                        .catch(() => {
                            setPopupLoading(marker.getPopup(), "ERROR");
                        });
                });

                return { key, marker };
            }

            function step() {
                const batch = [];
                const end = Math.min(i + CHUNK, data.length);

                for (; i < end; i++) {
                    const pump = data[i];
                    const { key, marker } = makeMarker(pump);
                    batch.push(marker);
                    pumpMarkers[key] = marker;
                }

                if (batch.length) markers.addLayers(batch);

                if (loadingMessage) loadingMessage.textContent = `LOADING… ${Math.min(i, data.length)}/${data.length}`;

                if (i < data.length) {
                    requestAnimationFrame(step);
                } else {
                    pumpsLoaded = true;
                    pumpsLoading = false;
                    hideLoading();
                    finalizePumpsLoad();
                }
            }

            step();
        } catch (e) {
            console.error("Ошибка загрузки pumps:", e);
            pumpsLoaded = false;
            pumpsLoading = false;
            hideLoading();
        }
    }

    const boilerLayer = L.layerGroup().addTo(map);
    const spMarkersByParam = {};
    let spLastUpdate = 0;

    function applySPState(marker, onoff) {
        const el = marker.getElement();
        if (!el) return;

        const ico = el.querySelector(".station-ico");
        if (!ico) return;

        if (ico.classList.contains("disp")) return;
        if (ico.classList.contains("cet")) return;

        if (onoff === null || onoff === undefined) return;

        ico.classList.remove("run", "stop");
        if (onoff === 1) ico.classList.add("run");
        else if (onoff === 0) ico.classList.add("stop");
    }

    function updateAllSPStates() {
        const now = Date.now();
        if (now - spLastUpdate < 5000) return;
        spLastUpdate = now;

        Object.entries(spMarkersByParam).forEach(([param, marker]) => {
            fetchJsonCached(`api/boiler_onoff/${encodeURIComponent(param)}/`, 3000, 15000)
                .then(d => applySPState(marker, d.onoff))
                .catch(() => {});
        });
    }

    fetch("api/boilers/")
        .then((res) => res.json())
        .then((data) => {
            data.forEach((boiler) => {
                const devName = (boiler.name_device || "").toUpperCase().trim();
                const paramName = (boiler.param_name || "").trim();

                const isSP = devName.startsWith("SP");
                const isDISP = devName.startsWith("DISP") || devName.includes("DISP") || (boiler.type_device === 4);
                const isCET = (boiler.type_device === 5) || devName.includes("CET") || devName.startsWith("SURSA");

                const cls = isSP ? "sp" : (isDISP ? "disp" : (isCET ? "cet" : "ct"));

                let initialState = "stop";
                if (isDISP) initialState = "run";
                if (isCET) {
                    if (paramName === "TabSin_CET2") initialState = "run";
                    else if (paramName === "TabSin_CET1") initialState = "stop";
                }

                const icon = L.divIcon({
                    className: "boiler-div-icon",
                    html: `
                        <div class="station-ico ${cls} ${initialState}">
                            ${cls === "sp" ? `<div class="rotor"></div>` : ``}
                            ${cls !== "sp" ? `<div class="tri"></div>` : ``}
                        </div>
                    `,
                    iconSize: isSP ? [28, 28] : (cls === "disp" ? [16, 14] : [50, 50]),
                    iconAnchor: isSP ? [14, 14] : (cls === "disp" ? [8, 14] : [25, 50]),
                    popupAnchor: isSP ? [0, -14] : (cls === "disp" ? [0, -14] : [0, -24]),
                });

                const marker = L.marker([boiler.latitude, boiler.longitude], {
                    icon: icon,
                    title: boiler.name_device,
                    number_map: boiler.sector_id || 0,
                }).bindPopup(`
                    <b>${boiler.name_device}</b><br>
                    ${boiler.address}<br>
                    <i>${boiler.param_name}</i><br>
                    <b>T1:</b> ... °C<br>
                    <b>T2:</b> ... °C
                `);

                // ✅ LOADING в попапе + живые температуры по popupopen
                marker.on("popupopen", () => {
                    setPopupLoading(marker.getPopup(), "LOADING...");

                    fetchJsonCached(`api/live_temp_boiler/${encodeURIComponent(boiler.param_name)}/`, 3000, 15000)
                        .then((d) => {
                            const t1Live = (d.T1 == null || isNaN(d.T1)) ? "N" : d.T1;
                            const t2Live = (d.T2 == null || isNaN(d.T2)) ? "N" : d.T2;
                            updatePopupTemps(marker.getPopup(), t1Live, t2Live);
                        })
                        .catch(() => {
                            setPopupLoading(marker.getPopup(), "ERROR");
                        });

                    if (!isDISP && !isCET) {
                        fetchJsonCached(`api/boiler_onoff/${encodeURIComponent(boiler.param_name)}/`, 3000, 15000)
                            .then(d => applySPState(marker, d.onoff))
                            .catch(() => {});
                    }
                });

                boilerLayer.addLayer(marker);

                if (!isDISP && !isCET) {
                    spMarkersByParam[boiler.param_name] = marker;
                    marker.on("add", () => {
                        fetchJsonCached(`api/boiler_onoff/${encodeURIComponent(boiler.param_name)}/`, 3000, 15000)
                            .then(d => applySPState(marker, d.onoff))
                            .catch(() => {});
                    });
                }
            });

            setInterval(updateAllSPStates, 20000);
            setTimeout(updateAllSPStates, 1500);
        })
        .catch((e) => console.error("Ошибка загрузки boilers:", e));

    (function() {
        if (L && (L.Control && (L.Control.Fullscreen || L.Control.FullScreen))) {
            if (L.Control.Fullscreen) map.addControl(new L.Control.Fullscreen());
            else if (L.Control.FullScreen) map.addControl(new L.Control.FullScreen());
        } else if (L.control && L.control.fullscreen) {
            L.control.fullscreen().addTo(map);
        } else {
            const FullscreenControl = L.Control.extend({
                options: { position: 'topleft' },
                onAdd: function() {
                    const container = L.DomUtil.create('div', 'leaflet-bar fullscreen-custom');
                    container.innerHTML = '<span>&#x26F6;</span>';
                    container.title = 'Full screen';
                    container.onclick = function(e) {
                        e.stopPropagation();
                        const mapDiv = document.getElementById('map');
                        if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement && !document.msFullscreenElement) {
                            if (mapDiv.requestFullscreen) mapDiv.requestFullscreen();
                            else if (mapDiv.mozRequestFullScreen) mapDiv.mozRequestFullScreen();
                            else if (mapDiv.webkitRequestFullscreen) mapDiv.webkitRequestFullscreen();
                            else if (mapDiv.msRequestFullscreen) mapDiv.msRequestFullscreen();
                        } else {
                            if (document.exitFullscreen) document.exitFullscreen();
                            else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
                            else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                            else if (document.msExitFullscreen) document.msExitFullscreen();
                        }
                        return false;
                    };
                    L.DomEvent.disableClickPropagation(container);
                    return container;
                }
            });
            map.addControl(new FullscreenControl());
        }
    })();

    const sectorPolygons = {};
    Object.entries(sectors).forEach(([sectorName, sectorData]) => {
        const polygon = L.polygon(sectorData.latlng, {
            color: sectorData.color,
            fillOpacity: 0.03,
            weight: 2,
            interactive: false,
        });

        sectorPolygons[sectorName] = polygon;
        polygon.addTo(map);
    });

    let zoomTimer = null;
    function handleZoom() {
        const z = map.getZoom();

        if (!pumpsLoaded && z >= 12) fetchAndRenderPumps();

        if (!pipelinesLoaded && z >= DETAILS_ZOOM) {
            fetchAndRenderPipelines();
        } else if (pipelinesLoaded && heatPipelineLayer) {
            const shouldShow = z >= DETAILS_ZOOM;
            const has = map.hasLayer(heatPipelineLayer);
            if (shouldShow && !has) map.addLayer(heatPipelineLayer);
            if (!shouldShow && has) map.removeLayer(heatPipelineLayer);
        }

        if (!zadviscaLoaded && z >= DETAILS_ZOOM) {
            fetchAndRenderZadvisca();
        } else if (zadviscaLoaded && zadviscaLayer) {
            const shouldShow = z >= DETAILS_ZOOM;
            const has = map.hasLayer(zadviscaLayer);
            if (shouldShow && !has) map.addLayer(zadviscaLayer);
            if (!shouldShow && has) map.removeLayer(zadviscaLayer);
        }
    }

    map.on("zoomend", function () {
        if (zoomTimer) clearTimeout(zoomTimer);
        zoomTimer = setTimeout(handleZoom, 80);
    });

    // ✅ стартовая проверка
    map.whenReady(() => {
        handleZoom();
        setTimeout(() => map.invalidateSize(), 0);
    });

    function saveSearchQuery(query) {
        if (!query) return;
        const history = JSON.parse(localStorage.getItem("searchHistory")) || [];
        if (!history.includes(query)) {
            history.push(query);
            localStorage.setItem("searchHistory", JSON.stringify(history));
        }
    }

    function updateSearchHistoryList() {
        const v = ($("#search-box").value || "").trim();
        if (v) updateSearchDatalistByPrefix(normalizePumpKey(v));
    }

    function showAllPumpsAndFit() {
        markers.clearLayers();
        Object.values(pumpMarkers).forEach((m) => markers.addLayer(m));
        if (markers.getLayers().length) map.fitBounds(markers.getBounds());
        setUrlPtc(null);
    }

    function searchObject() {
        const raw = ($("#search-box").value || "");
        const query = normalizePumpKey(raw);

        saveSearchQuery(query);

        if (!pumpsLoaded) fetchAndRenderPumps();

        markers.clearLayers();

        if (!query) {
            showAllPumpsAndFit();
            return;
        }

        const marker = pumpMarkers[query];
        if (marker) {
            markers.addLayer(marker);
            map.setView(marker.getLatLng(), 16);
            setUrlPtc(raw.trim());
            return;
        }

        alert("Obiectul nu a fost găsit!");
    }

    document.addEventListener("DOMContentLoaded", function () {
        updateSearchHistoryList();

        const q = getQueryFromUrl();
        if (q) {
            $("#search-box").value = q;
            pendingAutoQuery = normalizePumpKey(q);
            if (!pumpsLoaded) fetchAndRenderPumps();
        }

        $("#search-button").addEventListener("click", searchObject);

        $("#search-box").addEventListener("keydown", (e) => {
            if (e.key === "Enter") searchObject();
        });

        $("#search-box").addEventListener("focus", () => {
            if (!pumpsLoaded) fetchAndRenderPumps();
        });

        $("#search-box").addEventListener("input", function () {
            const v = this.value.trim();
            updateSearchDatalistByPrefix(normalizePumpKey(v));

            if (!v) {
                showAllPumpsAndFit();
                return;
            }

            if (pumpsLoaded && isExactExistingPtc(v)) {
                searchObject();
            }
        });

        $("#search-box").addEventListener("change", function () {
            const v = this.value.trim();
            if (pumpsLoaded && v && isExactExistingPtc(v)) {
                searchObject();
            }
        });

        const box = document.getElementById("limits-box");
        const tooltip = document.getElementById("limits-tooltip");
        box.addEventListener("mouseenter", () => tooltip.classList.remove("hidden"));
        box.addEventListener("mouseleave", () => tooltip.classList.add("hidden"));
    });

    const sectorButtonColors = { 1:"red", 2:"purple", 3:"green", 4:"orange", 6:"blue", 0:"white" };

    $$("#sector-buttons button").forEach((button) => {
        button.addEventListener("click", function () {
            const sectorNumber = parseInt(this.dataset.sector, 10);
            const sectorMap = { 1:"Centru", 2:"Riscani", 3:"Botanica", 4:"Buiucani", 6:"Ciocana", 0:"Arată Toate" };
            const sectorName = sectorMap[sectorNumber];

            if (!pumpsLoaded) fetchAndRenderPumps();

            markers.clearLayers();
            Object.values(sectorPolygons).forEach((polygon) => map.removeLayer(polygon));

            if (sectorName === "Arată Toate") {
                Object.values(pumpMarkers).forEach((marker) => markers.addLayer(marker));
                Object.values(sectorPolygons).forEach((polygon) => polygon.addTo(map));
                if (markers.getLayers().length) map.fitBounds(markers.getBounds());
            } else {
                Object.values(pumpMarkers).forEach((marker) => {
                    if (marker.options.number_map === sectorNumber) markers.addLayer(marker);
                });
                if (sectorPolygons[sectorName]) sectorPolygons[sectorName].addTo(map);
                if (markers.getLayers().length) map.fitBounds(markers.getBounds());
            }

            $$("#sector-buttons button").forEach((btn) => {
                btn.classList.remove("active");
                btn.style.borderColor = "#bbb";
            });

            const color = sectorButtonColors[sectorNumber] || "gray";
            this.classList.add("active");
            this.style.borderColor = color;
        });
    });

    const filterIcons = $$(".filter-icon");
    const statusList = document.getElementById("status-list");

    document.addEventListener("click", (event) => {
        if (!event.target.closest("#status-filter") && !event.target.closest("#status-list")) {
            statusList.classList.add("hidden");
        }
    });

    filterIcons.forEach((icon) => {
        icon.addEventListener("click", (event) => {
            event.stopPropagation();

            if (!pumpsLoaded) fetchAndRenderPumps();

            const color = icon.dataset.color;
            statusList.innerHTML = "";

            const matching = Object.entries(pumpMarkers).filter(
                ([name, marker]) => {
                    const html = marker.options.icon && marker.options.icon.options && marker.options.icon.options.html;
                    return typeof html === "string" && html.includes(`background-color:${color}`);
                }
            );

            if (matching.length === 0) {
                statusList.innerHTML = "<i>Nu sunt obiecte!</i>";
            } else {
                matching.forEach(([name, marker]) => {
                    const item = document.createElement("div");
                    item.textContent = name.toUpperCase();

                    const iconHtml = marker.options.icon.options.html || "";
                    const colorMatch = iconHtml.match(/background-color:([^;"]+)/);
                    const markerColor = colorMatch ? colorMatch[1].trim() : "#000";
                    item.style.color = markerColor;

                    item.addEventListener("click", () => {
                        markers.clearLayers();
                        markers.addLayer(marker);
                        map.setView(marker.getLatLng(), 16);
                        setUrlPtc(name);
                    });

                    statusList.appendChild(item);
                });
            }

            statusList.classList.remove("hidden");
        });
    });

    function pipeLabelRO(feature) {
    const t = (feature?.properties?.type_sys || "").toString().toLowerCase();
    if (t === "hs")  return "Încălzire / rețea termică";
    if (t === "hws") return "Apă caldă menajeră (ACM)";
    return "Rețea termică";
}



    async function fetchAndRenderPipelines() {
    if (pipelinesLoaded || pipelinesLoading) return;

    pipelinesLoading = true;
    showLoading("LOADING NETWORK…");

    try {
        const response = await fetchWithTimeout("{% static 'data/network_v2.geojson' %}", {}, 25000);
        if (!response.ok) throw new Error("Не удалось загрузить network_v2.geojson (HTTP " + response.status + ")");

        const geojsonData = await response.json();

        const pipeRenderer = L.canvas({ padding: 0.5 });

        heatPipelineLayer = L.geoJSON(geojsonData, {
    renderer: pipeRenderer,
    interactive: true,            // ✅ нужно для hover/tooltip
    bubblingMouseEvents: false,   // ✅ чтобы не мешало кликам по карте/маркерам
    style: (feature) => {
        const t = (feature?.properties?.type_sys || "").toString().toLowerCase();
        if (t === "hs")  return { color: "red",  weight: 3, opacity: 0.85 };
        if (t === "hws") return { color: "blue", weight: 3, opacity: 0.85 };
        return { color: "#888", weight: 2, opacity: 0.6 };
    },
    onEachFeature: (feature, layer) => {
        layer.bindTooltip(pipeLabelRO(feature), {
            sticky: true,       // ✅ подсказка “следует” за мышью
            opacity: 0.9,
            direction: "top",
        });
    },
});


        pipelinesLoaded = true;

        if (map.getZoom() >= DETAILS_ZOOM) heatPipelineLayer.addTo(map);
    } catch (e) {
        console.error("Pipelines load error:", e);
        pipelinesLoaded = false;
    } finally {
        pipelinesLoading = false;
        hideLoading();
    }
}

    function fetchAndRenderZadvisca() {
        if (zadviscaLoaded) return;
        zadviscaLoaded = true;

        fetch("{% static 'data/zadvisca.geojson' %}")
            .then((response) => response.json())
            .then((geojson) => {
                zadviscaGeojsonData = geojson;
                refreshZadviscaLayer();
            })
            .catch((e) => console.error(e));
    }

    fetch("api/get_ip/").then((r) => r.json()).then((d) => console.log("IP:", d.ip)).catch(() => {});
</script>


<div class="footer">
    © 2026 STIC SCADA — Inginer Victor Musteață · tel: 93-312
</div>

</body>
</html>
